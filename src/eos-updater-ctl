#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright Â© 2013 Sjoerd Simons <sjoerd.simons@collabora.co.uk>
#
# Quick test command line for eos-updater
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

import argparse
import sys
from gi.repository import Gio, GLib

UPDATER_STATES = [
    "None",
    "Ready",
    "Error",
    "Polling",
    "UpdateAvailable",
    "Fetching",
    "UpdateReady",
    "ApplyingUpdate",
    "UpdateApplied"
]

METHODS = {
    'poll': 'Poll',
    'fetch': 'Fetch',
    'apply': 'Apply',
}

current_proxy = None


def signal_emitted(proxy, signal, parameters):
    if signal != "StateChanged":
        return
    state = UPDATER_STATES[parameters[0]]
    print("======= State changed to: " + state + " =======")


def dump_daemon_properties(proxy):
    print("======= Properties =======")
    s = proxy.get_cached_property("State").get_uint32()
    print("State: " + UPDATER_STATES[s])

    for x in proxy.get_cached_property_names():
        if x != "State":
            print(" " + x + ": " + str(proxy.get_cached_property(x)))
    print("")


def name_appeared_cb(connection, name, name_owner):
    global current_proxy

    print("======= Ownership =======")
    print("%s appeared as %s" % (name, name_owner))

    proxy = Gio.DBusProxy.new_sync(connection,
                                   Gio.DBusProxyFlags.NONE,
                                   None,  # interface info
                                   name_owner,
                                   '/com/endlessm/Updater',
                                   'com.endlessm.Updater',
                                   None)  # cancellable

    proxy.connect('g-properties-changed',
                  lambda proxy, changed, invalidated, user_data: \
                      dump_daemon_properties(proxy), None)
    proxy.connect('g-signal',
                  lambda proxy, sender, signal, parameters, user_data: \
                      signal_emitted(proxy, signal, parameters), None)

    dump_daemon_properties(proxy)
    current_proxy = proxy


def name_vanished_cb(connection, name):
    global current_proxy

    current_proxy = None

    print("======= Ownership =======")
    print("%s disappeared" % name)


def run_command(command, bus):
    proxy = Gio.DBusProxy.new_sync(bus, 0, None,
                                   'com.endlessm.Updater',
                                   '/com/endlessm/Updater',
                                   'com.endlessm.Updater', None)
    proxy.call_sync("com.endlessm.Updater." + METHODS[command],
                    None,
                    0, -1, None)

    return 0


def monitor(bus):
    """Watch properties and signals from the updater indefinitely."""
    loop = GLib.MainLoop()
    name_watch_id = Gio.bus_watch_name_on_connection(
        bus, 'com.endlessm.Updater', Gio.BusNameWatcherFlags.NONE,
        name_appeared_cb, name_vanished_cb)

    try:
        loop.run()
    except KeyboardInterrupt:
        pass

    Gio.bus_unwatch_name(name_watch_id)

    return 0


def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='Control eos-updater stages.')
    parser.add_argument('command', choices=METHODS.keys(), nargs='?',
                        help='command to pass to eos-updater; '
                             'omit to monitor the updater')
    args = parser.parse_args()

    # Set up a D-Bus connection
    bus = Gio.bus_get_sync(Gio.BusType.SYSTEM, None)

    # Handle the given action.
    if args.command:
        status = run_command(args.command, bus)
    else:
        status = monitor(bus)

    sys.exit(status)


if __name__ == '__main__':
    main()
