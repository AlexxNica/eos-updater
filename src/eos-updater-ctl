#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright © 2013 Sjoerd Simons <sjoerd.simons@collabora.co.uk>
# Copyright © 2017 Endless Mobile, Inc.
#
# Quick test command line for eos-updater
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

import argparse
import sys
from gi.repository import Gio, GLib

UPDATER_STATES = [
    "None",
    "Ready",
    "Error",
    "Polling",
    "UpdateAvailable",
    "Fetching",
    "UpdateReady",
    "ApplyingUpdate",
    "UpdateApplied"
]

# Mapping from command name (given on the command line), to a tuple of
# (D-Bus method to call, state we expect eos-updater to transition into while
#  performing that action)
METHODS = {
    'poll': ('Poll', 'Polling'),
    'fetch': ('Fetch', 'Fetching'),
    'apply': ('Apply', 'ApplyingUpdate'),
}

current_proxy = None


def signal_emitted(proxy, signal, parameters):
    if signal != "StateChanged":
        return
    state = UPDATER_STATES[parameters[0]]
    print("======= State changed to: " + state + " =======")


def dump_daemon_properties(proxy):
    print("======= Properties =======")
    s = proxy.get_cached_property("State").get_uint32()
    print("State: " + UPDATER_STATES[s])

    for x in proxy.get_cached_property_names():
        if x != "State":
            print(" " + x + ": " + str(proxy.get_cached_property(x)))
    print("")


def name_appeared_cb(connection, name, name_owner):
    global current_proxy

    print("======= Ownership =======")
    print("%s appeared as %s" % (name, name_owner))

    proxy = Gio.DBusProxy.new_sync(connection,
                                   Gio.DBusProxyFlags.NONE,
                                   None,  # interface info
                                   name_owner,
                                   '/com/endlessm/Updater',
                                   'com.endlessm.Updater',
                                   None)  # cancellable

    proxy.connect('g-properties-changed',
                  lambda proxy, changed, invalidated, user_data: \
                      dump_daemon_properties(proxy), None)
    proxy.connect('g-signal',
                  lambda proxy, sender, signal, parameters, user_data: \
                      signal_emitted(proxy, signal, parameters), None)

    dump_daemon_properties(proxy)
    current_proxy = proxy


def name_vanished_cb(connection, name):
    global current_proxy

    current_proxy = None

    print("======= Ownership =======")
    print("%s disappeared" % name)


def command_dbus(command, block, quiet=False):
    """Run the given command and wait for it to complete."""
    bus = Gio.bus_get_sync(Gio.BusType.SYSTEM, None)
    (function_name, in_progress_state) = METHODS[command]

    def signal_cb(proxy, sender_name, signal_name, parameters, user_data):
        nonlocal seen_in_progress_state, seen_next_state

        if signal_name != 'StateChanged':
            return

        new_state = UPDATER_STATES[parameters[0]]
        if not quiet:
            print('Changed state to ' + new_state)

        if new_state == in_progress_state:
            seen_in_progress_state = True
        elif new_state != in_progress_state and seen_in_progress_state:
            seen_next_state = True

    proxy = Gio.DBusProxy.new_sync(bus, 0, None,
                                   'com.endlessm.Updater',
                                   '/com/endlessm/Updater',
                                   'com.endlessm.Updater', None)
    signal_id = proxy.connect('g-signal', signal_cb, None)
    context = GLib.main_context_default()

    # Call the method, wait for the updater to enter the expected in-progress
    # state; then wait for it to leave that state again (either to Error, or
    # the next state corresponding to the method).
    proxy.call_sync('com.endlessm.Updater.' + function_name, None, 0, -1, None)

    cancelled = False
    seen_in_progress_state = False
    seen_next_state = False

    while (block and
           not cancelled and
           not (seen_in_progress_state and seen_next_state)):
        try:
            context.iteration(True)
        except KeyboardInterrupt:
            cancelled = True

    proxy.disconnect(signal_id)

    # Print the final state of the properties before exiting.
    if block and not quiet:
        dump_daemon_properties(proxy)

    return 1 if cancelled else 0


def command_poll(block, quiet=False):
    return command_dbus('poll', block, quiet)


def command_fetch(block, quiet=False):
    return command_dbus('fetch', block, quiet)


def command_apply(block, quiet=False):
    return command_dbus('apply', block, quiet)


def command_monitor(quiet=False):
    """Watch properties and signals from the updater indefinitely."""
    bus = Gio.bus_get_sync(Gio.BusType.SYSTEM, None)
    loop = GLib.MainLoop()
    name_watch_id = Gio.bus_watch_name_on_connection(
        bus, 'com.endlessm.Updater', Gio.BusNameWatcherFlags.NONE,
        name_appeared_cb, name_vanished_cb)

    try:
        loop.run()
    except KeyboardInterrupt:
        pass

    Gio.bus_unwatch_name(name_watch_id)

    return 0


def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='Control eos-updater stages.')
    subparsers = parser.add_subparsers(metavar='command',
                                       help='command to pass to eos-updater; '
                                            'omit to monitor the updater')
    parser.set_defaults(function=command_monitor)
    parser.add_argument('--quiet', action='store_true',
                        help='output no informational messages')
    parser.set_defaults(quiet=False)

    # Common options for the D-Bus method subcommands.
    common_parser = argparse.ArgumentParser(add_help=False)
    group = common_parser.add_mutually_exclusive_group()
    group.add_argument('--no-block', dest='block',
                       action='store_false',
                       help='do not wait until eos-updater has finished all '
                            'processing in the requested state')
    group.add_argument('--block', dest='block', action='store_true',
                       help='opposite of --no-block')
    common_parser.set_defaults(block=True)

    parser_poll = subparsers.add_parser('poll', parents=[common_parser],
                                        help='check for updates')
    parser_poll.set_defaults(function=command_poll)

    parser_fetch = subparsers.add_parser('fetch', parents=[common_parser],
                                         help='download available updates')
    parser_fetch.set_defaults(function=command_fetch)

    parser_apply = subparsers.add_parser('apply', parents=[common_parser],
                                         help='deploy downloaded updates')
    parser_apply.set_defaults(function=command_apply)

    parser_monitor = subparsers.add_parser('monitor',
                                           help='watch eos-updater properties')
    parser_monitor.set_defaults(function=command_monitor)

    # Parse the command line arguments and run the subcommand.
    args = parser.parse_args()
    args_dict = dict((k, v) for k, v in vars(args).items() if k != 'function')
    sys.exit(args.function(**args_dict))


if __name__ == '__main__':
    main()
